import {
  NewFeedbackType,
  FeedbackType,
  StatusType,
  SuggestionType,
  Result,
  EditFeedbackFormValues,
} from "../types/feedback.types";
import { fetchWrapper } from "../utils/helpers";

export const API_URL: string = "http://localhost:9000"; //mock API generated by JSON server from data/data.json file

/* Fetch feedback list */
export async function fetchFeedbackList(
  pageContext: "feedbackBoard" | "developmentRoadmap"
): Promise<Record<StatusType, FeedbackType[]>> {
  const queryCondition =
    pageContext === "feedbackBoard" ? "" : "?status_ne=suggestion";

  const data = await fetchWrapper<FeedbackType[]>(
    `${API_URL}/productRequests${queryCondition}`
  );

  const feedbackEntriesByStatus = data.reduce(
    (acc: Record<StatusType, FeedbackType[]>, curr: FeedbackType) => {
      const status = curr.status;

      acc[status].push(curr);
      return acc;
    },
    { suggestion: [], planned: [], "in-Progress": [], live: [] }
  );

  return feedbackEntriesByStatus;
}

/* Fetch feedback by id */
export async function fetchFeedbackById(
  feedbackId: string
): Promise<FeedbackType> {
  return fetchWrapper<FeedbackType>(`${API_URL}/productRequests/${feedbackId}`);
}

/* Submit new feedback */
export async function submitFeedback(
  feedback: NewFeedbackType
): Promise<Result<SuggestionType>> {
  try {
    const data = await fetchWrapper<SuggestionType>(
      `${API_URL}/productRequests`,
      {
        method: "POST",
        body: JSON.stringify(feedback),
        headers: {
          "Content-Type": "application/json",
        },
      }
    );
    console.log("data create", data);
    return { success: true, payload: data };
  } catch (err) {
    console.error("Something went wrong inside SubmitFeedback", err);
    return { success: false, error: err };
  }
}

/* Edit feedback entry */
export async function editFeedback(
  feedbackId: string,
  editedFeedback: EditFeedbackFormValues
): Promise<Result<EditFeedbackFormValues>> {
  try {
    const data = await fetchWrapper<FeedbackType>(
      `${API_URL}/productRequests/${feedbackId}`,
      {
        method: "PATCH",
        body: JSON.stringify(editedFeedback),
        headers: {
          "Content-Type": "application/json",
        },
      }
    );

    const { title, category, status, description } = data;

    return { success: true, payload: { title, category, status, description } };
  } catch (err) {
    console.error("Something went wrong inside EditFeedback", err);
    return { success: false, error: err };
  }
}

/* Delete feedback entry */
export async function deleteFeedback(
  feedbackId: string
): Promise<FeedbackType> {
  return fetchWrapper<FeedbackType>(
    `${API_URL}/productRequests/${feedbackId}`,
    {
      method: "DELETE",
    }
  );
}

/* Update backend with current vote count after user's upvote/unvote actions */
export async function persistFeedbackVote(
  feedbackId: string,
  voteCount: number
): Promise<number> {
  try {
    const data = await fetchWrapper<FeedbackType>(
      `${API_URL}/productRequests/${feedbackId}`,
      {
        method: "PATCH",
        body: JSON.stringify({ upvotes: voteCount }),
        headers: {
          "Content-Type": "application/json",
        },
      }
    );

    return data.upvotes;
  } catch (err) {
    console.error("Something went wrong while upvoting feedback", err);
    throw err;
  }
}

/* Fetch user list */
export async function fetchUserList() {
  //return fetchWrapper(`${API_URL}/userList?username=${username}`);
}

/* Update commentCount when a new comment/reply is added - currently working only incrementing commentCount
   TO DO: use the same function to decrement commentCount when a comment/reply is deleted
*/
export async function updateCommentCount(
  feedbackId: string,
  updatedCommentCount: number
): Promise<number> {
  const data = await fetchWrapper<FeedbackType>(
    `${API_URL}/productRequests/${feedbackId}`,
    {
      method: "PATCH",
      body: JSON.stringify({ commentCount: updatedCommentCount }),
      headers: {
        "Content-Type": "application/json",
      },
    }
  );

  return data.upvotes;
}
